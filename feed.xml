<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mleek's blog</title>
    <description>Mleek's blog_ study note &amp; daily life
</description>
    <link>http://lee95292.github.io/</link>
    <atom:link href="http://lee95292.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 05 Dec 2019 00:39:35 +0900</pubDate>
    <lastBuildDate>Thu, 05 Dec 2019 00:39:35 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>[Jenkins] 젠킨스 원격 배포 (CD) 수행하기</title>
        <description>&lt;p&gt;젠킨스 서버에서 CI된 결과물을 원격 서버에 CD하기.&lt;/p&gt;

&lt;p&gt;선결조건&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;젠킨스 구동 중&lt;/li&gt;
  &lt;li&gt;CI(빌드) 세팅 완료&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;원리&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;publish over ssh 플러그인 사용&lt;/li&gt;
  &lt;li&gt;scp를 통해 배포파일 (spring의 경우는 **.jar) 전송&lt;/li&gt;
  &lt;li&gt;ssh를 통해 배포파일 실행(서버 가동스크립트)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jenkins-on-use--1------&quot;&gt;Jenkins on use -1 : 사전  설정 (원격지 등록)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Jenkins &amp;gt; Jenkins관리 &amp;gt; 시스템 설정화면&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/jenkins/jenkins_001.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;아래쪽 publish over ssh 탭 작성&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Key 탭 - 원격지에 접근하기 위한 키 작성&lt;/p&gt;

&lt;p&gt;SSH Servers탭 - 배포파일을 전송할 원격지&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Name - 구분을 위한 이름&lt;/li&gt;
  &lt;li&gt;hostname - 호스트 주소&lt;/li&gt;
  &lt;li&gt;username - 연결을 위한 유저 이름&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;왼쪽 아래 저장버튼을 눌러 원격지 등록 완료!&lt;/p&gt;

&lt;h3 id=&quot;jenkins-on-use--2---ci----&quot;&gt;Jenkins on use -2 : 프로젝트 빌드(CI) 이후 원격지로 실제 배포하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;각자 프로젝트  선택 &amp;gt; 구성 &amp;gt; Build탭의 add build step &amp;gt; send files or execute commands over SSH&lt;/strong&gt;
&lt;img src=&quot;/assets/img/jenkins/jenkins_002.PNG&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;접속 이후 수행동작 작성하기&lt;/strong&gt;
&lt;img src=&quot;/assets/img/jenkins/jenkins_003.PNG&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;항목들  설명&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;SSH Server - Name - 사전 설정과정에서 등록한 서버의 이름&lt;/li&gt;
  &lt;li&gt;Transfes
    &lt;ul&gt;
      &lt;li&gt;Source files : 젠킨스 서버에서 빌드 완료된 배포파일(전송할 배포파일)&lt;/li&gt;
      &lt;li&gt;Exec command : 배포파일 실행 명령&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;저장을 눌러 배포 설정 완료하고,&lt;/p&gt;

&lt;p&gt;빌드 수행!&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Dec 2019 08:07:01 +0900</pubDate>
        <link>http://lee95292.github.io/devops/2019/12/03/Jenkins-_publishOverSSL.html</link>
        <guid isPermaLink="true">http://lee95292.github.io/devops/2019/12/03/Jenkins-_publishOverSSL.html</guid>
        
        
        <category>devops</category>
        
      </item>
    
      <item>
        <title>[Spring Boot,토막글] Spring boot 프로젝트에서 여러개의 설정파일 추가</title>
        <description>&lt;p&gt;스프링에서 API Key 또는 비밀스러운 정보를 따로 관리해야 할 때(에를 들어 public git 시스템에 푸쉬), 역할에 따른 설정파일이 필요할 때는 application.yml 이외의 설정파일을 추가해야합니다.&lt;/p&gt;

&lt;p&gt;이 떄, 스프링 부트에서 설정파일을 나누는 방법으로, 별도의 설정 없이 ***.yml파일 추가 후, 아래 코드와 같이 실행파일의 경로를 등록해주면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@EnableGlobalMethodSecurity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;securedEnabled&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JclipProtoApplication&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;APPLICATION&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
											&lt;span class=&quot;s&quot;&gt;&quot;spring.config.location=&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
											&lt;span class=&quot;s&quot;&gt;&quot;classpath:/application.yml,&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
											&lt;span class=&quot;s&quot;&gt;&quot;classpath:/private.yml&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SpringApplicationBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JclipProtoApplication&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;APPLICATION&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		
&lt;span class=&quot;c1&quot;&gt;//		SpringApplication.run(JclipProtoApplication.class, args);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 13 Nov 2019 21:00:00 +0900</pubDate>
        <link>http://lee95292.github.io/spring/2019/11/13/multi_prop.html</link>
        <guid isPermaLink="true">http://lee95292.github.io/spring/2019/11/13/multi_prop.html</guid>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>[React] 리액트 라우터 on use</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;간단한 기록용 포스트&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;공통적으로,&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Router&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Link&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'react-router-dom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;route---path-component--&quot;&gt;Route - path와 component 속성으로 설명해보자.&lt;/h3&gt;

&lt;p&gt;exact path와 일치하는 component를 보여준다. 즉,&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;Route&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;exact&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;path=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;component=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;{Home}&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의 경우 url상에서 루트 경로일 때, Home 컴포넌트를 보여주는 것.&lt;/p&gt;

&lt;p&gt;즉, Route는 의미적(Semantic)인 컴포넌트이고, URL의 정보를 참조해서 뷰를 보여주는 역할을 수행한다.&lt;/p&gt;

&lt;p&gt;(이 때, exact path가 아니라 path만을 사용한다면, path=”/about” 인 설정의 경우, path=”/” 과 path=”/about”의 라우트까지 모두 보여준다.&lt;br /&gt;
즉, exact하지 않는 매칭을 한다)&lt;/p&gt;

&lt;h3 id=&quot;parameter&quot;&gt;Parameter&lt;/h3&gt;

&lt;p&gt;parameter는 url path 뒤에 콜론(:)을 붙여 입력받는다.&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import {Router} from 'react-router-dom';

...
 &lt;span class=&quot;nt&quot;&gt;&amp;lt;Route&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;path=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/about/:name&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;component=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;{About}/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;(전달예시)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://localhost:3000/about/mklee
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의 경우, ‘mklee’가 About 컴포넌트에 파라미터로 사용한다.&lt;/p&gt;

&lt;p&gt;이 때,  About의 컴포넌트는 &lt;strong&gt;const name=match.params.name&lt;/strong&gt; 과 같이 해당 값을 사용한다&lt;/p&gt;

&lt;h3 id=&quot;link-----router&quot;&gt;Link 컴포넌트를 통해 새로고침 없는 Router이동&lt;/h3&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import {Link} from 'react-router-dom'
...

&lt;span class=&quot;nt&quot;&gt;&amp;lt;Link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/about&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; About &lt;span class=&quot;nt&quot;&gt;&amp;lt;/Link&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;a 태그를 통해 URL을 변경시키고 이동할 수도 있지만, 새로고침 없이 Link 컴포넌트를 통해 새로고침 없는 페이지전환이 가능하다.&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Sep 2019 00:00:00 +0900</pubDate>
        <link>http://lee95292.github.io/react/2019/09/12/React-Router_on_use.html</link>
        <guid isPermaLink="true">http://lee95292.github.io/react/2019/09/12/React-Router_on_use.html</guid>
        
        
        <category>react</category>
        
      </item>
    
      <item>
        <title>React.js 기초 튜터리얼, 개념 편 [1]</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://ko.reactjs.org&quot;&gt;React.js 기초 튜터리얼&lt;/a&gt;을 학습하며 작성하는 글입니다. 오류가 있을 수 있으며, 이메일을 통한 오류 수정 환영합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;jsx&quot;&gt;JSX&lt;/h1&gt;
&lt;hr /&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;h1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/h1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위와 같은 문법으로 JSX를 작성한다.&lt;/p&gt;

&lt;p&gt;JSX는 Javascript의 String도 아니고, HTML역시 아닌데, JSX는 &lt;strong&gt;React Element&lt;/strong&gt;를 생성하고, DOM에 렌더링한다.&lt;/p&gt;

&lt;h3 id=&quot;reactjs-&quot;&gt;React.js의 컴포넌트&lt;/h3&gt;
&lt;hr /&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'mklee'&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;h1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/h1&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ReactDOM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;gelElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'root'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;JSX의 중괄호 안에는 모든 Javascript 표현식이 들어갈 수 있다.&lt;/p&gt;

&lt;p&gt;부연설명 -  이는 React의 컴포넌트가 로직과 뷰를 분리하지 않는다는 특성과 관련있다. 컴포넌트는 엘리먼트를 포함하는 개념으로만 알고있자.&lt;/p&gt;

&lt;p&gt;(참고로, JSX는 뷰와 로직이 섞여있기는 하지만, Javascript에 더 가깝기에, Camelcase 변수 표기법을 사용한다.)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JSX 예제&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;profileURL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&amp;gt;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이처럼,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Attribute에도 Javascript 표현식이 들어갈 수 있고,&lt;/li&gt;
  &lt;li&gt;자식으로 JSX를 포함할 수도 있다.&lt;/li&gt;
  &lt;li&gt;인터프리터 언어 특성 상, 줄바꿈 시 자동 세미콜론이 등록되므로, 엘리먼트 범위를 소괄호로 묶어주거나 한 줄에 작성하도록 하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;react--&quot;&gt;React의 엘리먼트 렌더링&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;앞의 예제에서 살펴보았듯,  &lt;strong&gt;ReactDOM.render(element,,target)&lt;/strong&gt;를 통해 엘리먼트를 렌더링한다.&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;렌더링된 엘리먼트 업데이트&lt;/h3&gt;

&lt;p&gt;React의 엘리먼트는 불변객체(const로 선언)이므로, 이것의 내용을 변경할 수 없다.&lt;/p&gt;

&lt;p&gt;하지만, 새로운 Element를 생성하고 이를 렌더링하는 방식으로 극복할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;h1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'s {new Date().toLocaleTimeString()} &amp;lt;/h1&amp;gt;
    );
    ReactDOM.render(element,document.getElementById('&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;setInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;참고 - 이후에 배우는 개념을 학습하면…&lt;/p&gt;

&lt;p&gt;유상태 컴포넌트(엘리먼트 변경이 있는 컴포넌트)는 대부분 한번의 rㅣender하는 방식으로 작성할 수 있다.
ReactDom은 변경이 필요한 경우에만 업데이트를 수행한다.&lt;/p&gt;

&lt;h1 id=&quot;component-props&quot;&gt;Component와 Props&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;UI를 분리하여 재사용 가능하도록 하는 React의 유닛을 컴포넌트라고 한다.&lt;/p&gt;

&lt;p&gt;또한, 속성을 나타내는 props 객체를 통해 결과를 표현합니다.&lt;/p&gt;

&lt;p&gt;컴포넌트 선언 시, 이름의 첫글자는 대문자입니다(컨벤션).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;함수 컴포넌트&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Welcome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;h1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/h1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;props객체를 인자로 받아 React 앨리먼트를 반환하는 Javascript 함수를 유효한 함수 컴포넌트라고 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;클래스 컴포넌트&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Welcome&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;h1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/h1&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;응용 - 사용자 정의 컴포넌트로 엘리먼트 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Welcome&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mklee&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;컴포넌트 렌더링&lt;/h3&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Welcome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;h1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/h1&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Welcome&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Sara&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ReactDOM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'root'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;state-lifecycle&quot;&gt;State와 LifeCycle&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;위쪽 파트에서 작성한 시계 코드를 리팩토링 해보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기존 코드&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;h1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'s {new Date().toLocaleTimeString()} &amp;lt;/h1&amp;gt;
    );
    ReactDOM.render(element,document.getElementById('&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;setInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;UI를 업데이트하기 위해 ReactDOM.render()를 호출해주었는데, state 개념을 활용해 효율적인 코드를 작성한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;컴포넌트로 분리하기&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Clock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;h1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'s props.date.toLocaleTimeString()&amp;lt;/h1&amp;gt;
    );
}

function tick(){
    ReactDOM.render(
        &amp;lt;Clock date={new Date()}/&amp;gt;,
        document.getElementById('&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;setInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위 코드의 문제점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;한번의 실행이 업데이트를 수행하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;해결방법?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;state를 사용하자&lt;/li&gt;
  &lt;li&gt;state는 props와 유사한 개념&lt;/li&gt;
  &lt;li&gt;props와 달리 비공개 객체&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;코드 수정하기&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;우선, 함수 컴포넌트를 클래스 컴포넌트로 전환하고&lt;/li&gt;
  &lt;li&gt;render()의 리턴으로 해당 JSX를 추가&lt;/li&gt;
  &lt;li&gt;생성자를 아래와 같이 작성하고, status를 초기화해주기&lt;/li&gt;
  &lt;li&gt;React의 컴포넌트 생명주기 메서드인 componentDidMount(), componentDidMount()를 작성해 시계가 랜더링될 때와 언마운트 될때의 수행코드 작성&lt;/li&gt;
  &lt;li&gt;매 초 status를 변경해주는 tick함수 작성. (이 떄, status값의 수정은 setStatus를 통해서만 갱신된다)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Clock&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;   
    &lt;span class=&quot;nx&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;     
        &lt;span class=&quot;kr&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()};&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;componentDidMount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;timerID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;componentWillUnmount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;clearInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;timerID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;h1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'s {this.props.state.date.toLocaleTimeString()}&amp;lt;/h1&amp;gt;;
    }
}

ReactDOM.render(
    &amp;lt;Clock /&amp;gt;,
    document.getElementById('&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;실행과정&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ReactDOM.render()&lt;/strong&gt;의 Clock 컴포넌트의 생성자를 호출하고 status 초기화됨.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Clock의 render()&lt;/strong&gt;가 호출된다. 이제부터 React에서 화면에 표시될 내용과 Clock의 렌더링 출력을 비교해 DOM을 업데이트한다.&lt;/li&gt;
  &lt;li&gt;DOM이 업데이트 된 이후, componentDidMount() (마운트 동작)를 호출하고, 매 초 tick()함수를 호출하며, tick()함수에서는 status를 새로운 날짜로 갱신합니다.&lt;/li&gt;
  &lt;li&gt;만약 Clock 컴포넌트가 삭제된다면, clearInterval을 통해 타이머가 중지됩니다.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 13 Sep 2019 00:00:00 +0900</pubDate>
        <link>http://lee95292.github.io/react/2019/09/12/ReactTutorial.html</link>
        <guid isPermaLink="true">http://lee95292.github.io/react/2019/09/12/ReactTutorial.html</guid>
        
        
        <category>react</category>
        
      </item>
    
      <item>
        <title>Junit 기초 사용법</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=tyZMdwT3rIY&quot;&gt;박재성님 Junit 강좌&lt;/a&gt; 정리&lt;/p&gt;

&lt;h1 id=&quot;junit--&quot;&gt;Junit 기본 사용법&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;(setup)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;STS에 J&lt;strong&gt;unit 라이브러리가 추가되어 있어야 함&lt;/strong&gt;. build path에서 추가.&lt;/li&gt;
  &lt;li&gt;Junit Test 버튼 클릭으로 테스트 클래스 생성&lt;/li&gt;
  &lt;li&gt;Test Annotation을 추가한 메서드 내에서 단위테스트 진행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(using)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;하나의 메서드만 테스트를 원할경우, 메서드 이름에 커서를 올린 상태로, Ctrl + f11&lt;/li&gt;
  &lt;li&gt;결과값 확인은, assertEquals(기댓값,결과값), assert류 메서드를 사용해 확인한다. 이 메서드가 false를 반환하면, testcase가 실패하게 된다.&lt;/li&gt;
  &lt;li&gt;인스턴스의 테스트간 독립성을 보장하기 위해 @Before 애너테이션을 통해 초기화 진행하자. 테스트케이스별로 인스턴스 초기화 작업 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;...&lt;/span&gt;

 &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt; 

    &lt;span class=&quot;nd&quot;&gt;@Before&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Calculator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//후에 수행되는 모든 TestCase에 대해 해당 초기화작업 진행&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;자원 반납과 같은 후처리 작업의 경우, @After 애너테이션을 사용한다&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 31 Aug 2019 00:00:00 +0900</pubDate>
        <link>http://lee95292.github.io/tdd/2019/08/30/Junit-JunitStart.html</link>
        <guid isPermaLink="true">http://lee95292.github.io/tdd/2019/08/30/Junit-JunitStart.html</guid>
        
        
        <category>TDD</category>
        
      </item>
    
      <item>
        <title>REST API 핵심개념 체크</title>
        <description>&lt;p&gt;참고 링크&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://meetup.toast.com/posts/92&quot;&gt;REST API 제대로 알고 사용하기&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://www.youtube.com/watch?v=RP_f5dMoHFc&quot;&gt;그런 REST API로 괜찮은가(유튜브)&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;rest-api&quot;&gt;REST API란?&lt;/h3&gt;

&lt;p&gt;다음 조건을 만족하는 분산 하이퍼미디어 시스템(웹)을 위한 아키텍처 스타일의(제약조건) 집합&lt;/p&gt;

&lt;p&gt;즉, 웹을 구현할 떄 사용되는 어떤 &lt;a href=&quot;https://ko.wikipedia.org/wiki/REST#REST_%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%97%90_%EC%A0%81%EC%9A%A9%EB%90%98%EB%8A%94_6%EA%B0%80%EC%A7%80_%EC%A0%9C%ED%95%9C_%EC%A1%B0%EA%B1%B4&quot;&gt;제약조건&lt;/a&gt;들의 집합&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;client - server :클라이언트가 요청하고 서버가 응답하는 구조&lt;/li&gt;
  &lt;li&gt;stateless : 서버가 클라이언트의 상태를 저장하지 않음&lt;/li&gt;
  &lt;li&gt;cache : 캐시(지역성과 공간성에 의존해 데이터 캐싱)&lt;/li&gt;
  &lt;li&gt;uniform interface&lt;/li&gt;
  &lt;li&gt;layered system&lt;/li&gt;
  &lt;li&gt;code on demand (optional) : 서버에서 클라이언트의 동작 가능하게함 (EX. javascript)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;4.Uniform Interface&lt;/strong&gt;가 가장 신경써야하는 제약조건, 구성요소를 살펴보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Identification of resource                       - 자원이 URI로 대표되어야 한다. (대체적으로 잘 지켜짐)&lt;/li&gt;
  &lt;li&gt;manipulation of resource through representations - 리소스의 행위를 HTTP 메서드로서 수행해야 한다(잘 지켜짐)&lt;/li&gt;
  &lt;li&gt;self-descriptive messages                        - 메시지는 스스로를 설명해야 한다 (잘 지켜지지 않음!)&lt;/li&gt;
  &lt;li&gt;메시지가 도달하는 경로&lt;/li&gt;
  &lt;li&gt;응답메시지의 문법(의미전달)
 잘 지켜진 응답메시지 예시를 살펴보자&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;```
 HTTP/1.1 200 OK
 Content-Type: application/json-patch+json
 HOST: example.com&lt;/p&gt;

&lt;p&gt;[ { “op” : “remove”, “path”: “a/b/c” } ]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
 [json-patch+json](https://en.wikipedia.org/wiki/JSON_Patch)은 JSON을 문서의 변경을 알리는 웹 표준 포멧이다. op(Operation)에는 add, remove, replace, copy, move, test등의 메서드가 자리할 수 있다.
 * HATEOAS 애플리케이션의 상태는 Hyperlink를 이용해 전이되어야 한다. (잘 지켜지지 않는 경우가 많다.)


### 디자인 특징
* Representational State Transfer - URI가 하나의 Resource를 표헌한다.
* 자원에 대한 행위를 HTTP 메서드로서 표현할 수 있다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;DELETE /article/3
```&lt;/p&gt;

</description>
        <pubDate>Sat, 31 Aug 2019 00:00:00 +0900</pubDate>
        <link>http://lee95292.github.io/web/2019/08/30/HTTP-REST_API.html</link>
        <guid isPermaLink="true">http://lee95292.github.io/web/2019/08/30/HTTP-REST_API.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>[etc]2019 2schedule</title>
        <description>&lt;!-- ---
layout : post
title : &quot;2019년 상반기 회고 및 계획&quot;
date : 2019-02-16 09:46:00 +9000
categories: 회고
---

사실 &quot;상반기&quot; 회고라고 하기에는 하반기가 4개월밖에 안남아서 1학기 &amp; 여름방학 회고 정도가 맞지 않을까 싶다.

뭐 어쨌든 상반기는 상반기니까, 나의 2019년 상반기를 한 단어로 표현해본다면,

**허둥지둥** 이다. 

나의 동기는 너무 가볍고 쉽게 이동한다. 우선순위가 정해져있지 않고, 행동의 기반이 깊지 않다.

물론 힘빠져서 축 늘어져있는 언젠가보다야 낫겠지만, 나를 움직이는 동력이 커다란 돌을 움직일 수 있는 동력은 아닌것 같다.

진행중이다가 내팽기쳐진 몇 가지 작은 프로젝트들에게 조의를 표하며 회고를 작성한다 :) 

이것이 어느정도 어쩔 수 없었던 이유는, 내 주변에서 여러가지 요구사항과 유혹들 있었고, 이것들을 처리하기 위해서는 내가 하던 일의 우선순위를 낮추고 요구사항을 처리해야 했었다.

몇 가지 일을 처리하면서 체력이 떨어지고, 자꾸 누워있게 되고, 집중하지 못했다.

이런 일들을 처리하면서 원하든 원치않든 어떤 종류의 능력의 상향이 있었지만, 내가 원하는 목표에 직접적으로 영향을 미칠지는 의문이다.


## 그래서 무엇을 했지?
---

*

## 무엇을 못했지?
---

* 내 블로그에 처참한 포스팅 흔적만 남아있는 네이버 부스트코스
* sqld 자격증 공부
* Openstack


## 이제 어떤 일을 할 차례인지?
---

커다란 계획을 세우면 항상 작고 손쉬운, 새로운 일이 생겨난다.

나는 커다란 계획에 겁먹고 잠시 쉬기 위해 쉬운 일을 잡고, 그 일을 끝내며 

&quot;큰건 못했지만 이걸 잘 했으니 됐어, 내일까지는 좀 쉬자!&quot; &lt;&lt; 아주 익숙한 합리화이다. 

이번엔 커다란 돌을 작게 쪼개보려 한다. 

* 1 커다란 돌 -  JClip 서비스 운영

 * 1-1 작은 돌들 - 서비스 운영기술 : jcloud 서버올리기 &gt; 도커 &gt; git
 * 1-2 작은 돌들 - 프로그래밍 스킬 : spring boot &gt; sprint data jpa &gt; spring security &gt; elk stack or chart tools &gt; log4j &gt; Java &gt; 
 * 1-3 작은 돌들 - 

* 2 중간 돌 - Serbia Korea Iac 업무처리
 * 2-1 Kotlin 또는 Android 공부

* 3 중간 돌 - TOPCIT 정기평가 : 9.20  --&gt;
</description>
        <pubDate>Mon, 26 Aug 2019 00:00:00 +0900</pubDate>
        <link>http://lee95292.github.io/2019/08/26/etc-2019-2Schedule.html</link>
        <guid isPermaLink="true">http://lee95292.github.io/2019/08/26/etc-2019-2Schedule.html</guid>
        
        
      </item>
    
      <item>
        <title>[INTG Project] 개념이 잘 정리된 링크| 테크블로그| 공식 Document 모음</title>
        <description>&lt;p&gt;Spring boot - cloud - database - frontend - devops -security&lt;/p&gt;

&lt;p&gt;웹 서비스를 위한 폭넓은 개발스택을 갖추길 희망합니다.&lt;/p&gt;

&lt;p&gt;저만을 위한 링크북 인덱스이고, 제가 이해한 글들을 모아놓았지만, 비슷한 목표를 가진분들이 참고하시면 좋을것 같습니다.&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;개념이 잘 정리된 링크&lt;/h1&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;OS/Linux/Windows
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://wiki.kldp.org/HOWTO/html/Adv-Bash-Scr-HOWTO/&quot;&gt;고급 쉘 스크립트 사전&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://blog.lael.be/post/73&quot;&gt;우분투 서버세팅(운영환경 관련 bash명령어)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;웹
    &lt;ul&gt;
      &lt;li&gt;Front
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://velog.io/@jeff0720/React-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD%EC%9D%84-%EA%B5%AC%EC%B6%95%ED%95%98%EB%A9%B4%EC%84%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-Webpack-%EA%B8%B0%EC%B4%88#%EC%9B%B9%ED%8C%A9%EC%9C%BC%EB%A1%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%8C%8C%EC%9D%BC-%EB%B9%8C%EB%93%9C%ED%95%98%EA%B8%B0&quot;&gt;Webpack X React&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Back
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://blog.outsider.ne.kr/1160&quot;&gt;JWT 개념&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://all-record.tistory.com/186&quot;&gt;우분투환경에서 단순 배포하기_W&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Spring
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://jeong-pro.tistory.com/167&quot;&gt;Spring bean 생성과정&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클라우드
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://medium.com/harrythegreat/aws-%EA%B0%80%EC%9E%A5%EC%89%BD%EA%B2%8C-vpc-%EA%B0%9C%EB%85%90%EC%9E%A1%EA%B8%B0-71eef95a7098&quot;&gt;VPC(Virtual Private Clout)개념, 클라우드 네트워크 헷갈릴 때 보기&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;git &amp;amp; github
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://git-scm.com/book/ko/v2/Git-%EB%8F%84%EA%B5%AC-Reset-%EB%AA%85%ED%99%95%ED%9E%88-%EC%95%8C%EA%B3%A0-%EA%B0%80%EA%B8%B0&quot;&gt;git reset(add,commit 리셋)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기타
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://heropy.blog/2017/09/30/markdown/&quot;&gt;Markdown 문법&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;document&quot;&gt;공식 Document&lt;/h1&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.docker.com&quot;&gt;도커&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/ko/docs/home/&quot;&gt;k8s(한글)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.spring.io/&quot;&gt;Spring&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kgmyh.github.io/blog/2017/12/02/spring-boot-chapter01/&quot;&gt;spring boot(한글)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/&quot;&gt;Java8 API&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com&quot;&gt;Android&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://nodejs.org/api/&quot;&gt;node&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-1&quot;&gt;기업| 개인 기술블로그&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;사실 &lt;a href=&quot;https://medium.com/@Dongmin_Jang/%EC%97%85%EC%B2%B4%EB%B3%84-%EA%B8%B0%EC%88%A0-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A6%AC%EC%8A%A4%ED%8A%B8-e2d736d0e658&quot;&gt;테크블로그는 여기&lt;/a&gt;에 다 정리되어있다. 내가 자주보는 한글 블로그 위주로 모았다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://d2.naver.com/home&quot;&gt;네이버 D2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://tech.kakao.com/&quot;&gt;카카오 기술블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/coupang-tech&quot;&gt;쿠팡 기술블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xguru.net/&quot;&gt;구루(권정혁님) 기술블로그&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 13 Aug 2019 14:46:00 +0900</pubDate>
        <link>http://lee95292.github.io/%ED%95%98%EB%82%98%EB%A1%9C_%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0/2019/08/13/INTG_TheoryLink-TheoryLink.html</link>
        <guid isPermaLink="true">http://lee95292.github.io/%ED%95%98%EB%82%98%EB%A1%9C_%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0/2019/08/13/INTG_TheoryLink-TheoryLink.html</guid>
        
        
        <category>하나로_정리하기</category>
        
      </item>
    
      <item>
        <title>[BoostCourse] PJ3 BackEnd 강의 정리(Spring MCV 실습 및 레이어드 아키텍쳐)</title>
        <description>&lt;p&gt;&lt;em&gt;작성중인 포스트입니다&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;실습을 따라하는 과정을 포스팅하는 것은 의미없다고 생각했습니다.&lt;/p&gt;

&lt;p&gt;내용이 많아 강사님이 자세히 설명하시지 않았지만 스프링을 처음 접하는 입장에서 그냥 넘어가기에는 찝찝한 부분들이 꽤나 있는것 같습니다.&lt;/p&gt;

&lt;p&gt;능동적으로 코드를 작성하기 위해 소스코드를 분석해보고, 관련 정보들을 기록하려 합니다.&lt;/p&gt;

&lt;p&gt;(레이어드 아키텍처 실습부분은 따라가기만으로도 벅차서, 완성도 있는 정리할 여유가 있을지 모르겠습니다..)&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;애너테이션&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;@Datasource&lt;/li&gt;
  &lt;li&gt;@Bean&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;bean을 정의하는 어노테이션&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@ComponentScan&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;@Controller, @Service, @Repository, @Component 어노테이션이 붙은 클래스를 찾아 컨테이너에 등록&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@Component&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;컴포넌트 스캔의 대상이 되는 애노테이션 중 하나로써 주로 유틸, 기타 지원 클래스에 붙이는 어노테이션&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@Autowired&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;주입 대상이되는 bean을 컨테이너에 찾아 주입하는 어노테이션&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Jul 2019 21:00:00 +0900</pubDate>
        <link>http://lee95292.github.io/boostcourse/2019/07/21/Boostcourse-PJ3_Backend_Spring2.html</link>
        <guid isPermaLink="true">http://lee95292.github.io/boostcourse/2019/07/21/Boostcourse-PJ3_Backend_Spring2.html</guid>
        
        
        <category>boostcourse</category>
        
      </item>
    
      <item>
        <title>[BoostCourse] PJ3 BackEnd 강의 정리(Spring 개요)</title>
        <description>&lt;h2 id=&quot;spring&quot;&gt;Spring이란?&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;엔터프라이즈급 웹 어플리케이션을 제작하기 위한 솔루션. AOP, IoC, DI, 선언적 트랜잭션등 여러 기능을 제공하며,&lt;/p&gt;

&lt;p&gt;이들의 모듈화된 부분들을 사용할 수 있도록 설계된 프레임워크.&lt;/p&gt;

&lt;p&gt;여기서 프레임워크란, 라이브러리와는 확연한 차이가 있다.&lt;/p&gt;

&lt;p&gt;강의에서는 라이브러리와 프레임워크를 원재료와 반제품으로 묘사하였다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;라이브러리 - 자주 사용하는 기능들을 함수 또는 기능으로 제작하여, 컴파일 타임에 링킹되는 소스코드(또는 기능)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프레임워크 - 자주 사용되는 기능이나 기본적인 실행환경 및 구조를 제공한다. (Spring에서는 DI,IoC,AOP etc..)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A 라이브러리 사용한 프로그램이 어떤 종류의 프로그램인지 알지 못하지만–&amp;gt;’원재료 비유’,&lt;/p&gt;

&lt;p&gt;B 프레임워크에서 동작하는 프로그램은 어떤 프로그램인지 알 수 있다. –&amp;gt; ‘반제품 비유’
BCI : 실행시간에 .class 바이트코드 수정&lt;/p&gt;

&lt;h2 id=&quot;spring-framework---&quot;&gt;Spring Framework의 모듈 및 특징&lt;/h2&gt;

&lt;h3 id=&quot;aop-instrumentation&quot;&gt;&lt;strong&gt;AOP와 Instrumentation&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;AOP가 뭔데?&lt;/strong&gt; __important&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.naver.com/kyh31126/221496146885&quot;&gt;AOP_링크&lt;/a&gt; - 자세한 AOP 설명은 여기에서 많이 참고했다.&lt;/p&gt;

&lt;p&gt;Aspect Oriented Programming 직역하면 관점지향 프로그래밍인데, 이는 비즈니스 로직과 공통 모듈을 구분하여, 비즈니스 로직에 공통 모듈을 삽입하는 개발 방법이다.&lt;/p&gt;

&lt;p&gt;대표적으로 메소드의 성능을 검사할 때, 비즈니스 로직에 System.currentTimeMills() 메서드를 삽입해 성능을 측정하는 방법이 있지만, AOP를 이용해 해당 로직 밖에서 성능 측정코드를 삽입하는 AOP방법이 사용된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;spring-AOP - AOP얼라이언스와 호환되는 방법으로 AOP지원&lt;/li&gt;
  &lt;li&gt;spring-aspects - AspectJ와의 통합 제공 (AspectJ는 BCI 제공 툴)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Spring의 AOP에는 &lt;a href=&quot;https://ukja.tistory.com/17&quot;&gt;BCI(Btye Code Instrumentation)&lt;/a&gt; 이라는 기술이 핵심적으로 사용된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;spring-instrument&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;messaging&quot;&gt;&lt;strong&gt;Messaging&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;메시지란, 네트워크에서 컴퓨터간 일반 통신을 의미.&lt;/p&gt;

&lt;p&gt;spring-messaging - 스프링4에서는 메시지 기반 어플리케이션을 작성하기 위해 Message, MessageChannel, MessageHadler, 메시지 매핑 어노테이션 제공&lt;/p&gt;

&lt;h3 id=&quot;data-access-integration&quot;&gt;&lt;strong&gt;Data Access/ Integration&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;spring-jdbc, spring-tx(선언적 트랜잭션 관리), spring-orm(JPA,JDO,Hibernate), spring-oxm, spring-jms&lt;/p&gt;

&lt;h3 id=&quot;web&quot;&gt;&lt;strong&gt;Web&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;spring-web - 멀티파트 파일 업로드, 서블릿 리스너 등의 웹 지향 통합 기능 제공&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;spring-webmvc - webservlet모듈, SpringMVC 및 REST 웹서비스 구현 포함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;spring-websocket - 웹소켓  지원&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;XML, java_config 설정부분&lt;/p&gt;

&lt;p&gt;Spring JDBC 부분&lt;/p&gt;

&lt;h2 id=&quot;spring-mvc--important&quot;&gt;Spring MVC  __important&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;MVC?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Model - View - Controller&lt;/p&gt;

&lt;p&gt;서비스에서 저장되는 데이터, 주문목록, 회원정보, 상품목록 자체를 &lt;strong&gt;Model&lt;/strong&gt;이라고 함.&lt;/p&gt;

&lt;p&gt;최종적으로 말단 기기에서 유저에게 보여지는 화면. 또는 화면을 렌더링하는 주체를 &lt;strong&gt;View라고&lt;/strong&gt; 함&lt;/p&gt;

&lt;p&gt;사용자의 요청에 의해 Model에서 비즈니스 로직을 거쳐 View를 만들기 까지의 액션을 수행하는 주체를 &lt;strong&gt;Controller&lt;/strong&gt;라고 함&lt;/p&gt;

&lt;p&gt;웹 상에서 MVC  구조는 몇 단계의 발전을 이뤄왔다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/boostcourse/mvc.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 MVC 구조에서는 JSP Page 내에 html과 java 코드가 섞여있어 유지/보수가 힘들었다.&lt;/p&gt;

&lt;p&gt;뷰를 담당하는 영역과 컨트롤을 담당하는 영역이 혼재되어 있어, 한사람이 본다면 문제가 없겠지만,&lt;/p&gt;

&lt;p&gt;뷰와 컨트롤을 담당하는 사람이 분리된 프로젝트의 경우 상당한 불편함을 초래했다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/boostcourse/mvc1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MVC2 구조에서는 요청을 servlet이 받아, Controll 작업을 수행해, 로직과 뷰를 분리하였다.&lt;/p&gt;

&lt;p&gt;이는 다음과 같은 장점을 갖는다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;관리 및 테스트의 용이&lt;/li&gt;
  &lt;li&gt;확장성 증가&lt;/li&gt;
  &lt;li&gt;관심사의 효과적인 분리&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/boostcourse/mvc2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 MVC2 발전형태에서는, Front Controller가 요청을 받고, 또 다른 Controller 클래스가 요청을 위임받는다.&lt;/p&gt;

&lt;p&gt;이를 ControllerClass, HandlerClass라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;spring-mvc-&quot;&gt;Spring MVC 구성요소&lt;/h3&gt;

&lt;p&gt;Spring은 model2 아키텍처로 구현되어 있음.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/boostcourse/springmvc.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;mvc---important&quot;&gt;&lt;strong&gt;mvc 동작순서&lt;/strong&gt;  __important&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;HandlerMapping객체 통해 어떤 Controller가 동작할 것인지 Mapping 조회 (자바 config or xml) –&amp;gt;2&lt;/li&gt;
  &lt;li&gt;Handler Adapter를 통해 실행할 Controller에게 실행 요청 –&amp;gt;3,4&lt;/li&gt;
  &lt;li&gt;컨트롤러가 리턴하는 뷰를 DispatcherServlet에 전달–&amp;gt;5&lt;/li&gt;
  &lt;li&gt;View Resolver와 View 이름을 통해 뷰를 조회하고 –&amp;gt;6 뷰를 렌더링 후 응답 –&amp;gt;7,8&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;붉은색(보라색) 부분이 개발자가 구현하는 부분.&lt;/p&gt;

&lt;p&gt;초록색은 가끔씩 개발자가 구현하는 부분.&lt;/p&gt;

&lt;h3 id=&quot;dispatcherservlet-&quot;&gt;DispatcherServlet 동작과정&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/boostcourse/dpservlet.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요청 선처리 작업 (뒷부분에서 추가설명)&lt;/li&gt;
  &lt;li&gt;HandelrExecutionChain 탐색&lt;/li&gt;
  &lt;li&gt;HandlerExecutionChain 결정 –&amp;gt; 없으면 404에러 출력&lt;/li&gt;
  &lt;li&gt;HandelrAdapter 결정 –&amp;gt;없다면 ServletException 발생&lt;/li&gt;
  &lt;li&gt;요청 처리&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dispatcherservlet--1&quot;&gt;요청 선처리 작업 (DispatcherServlet) 동작과정&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/boostcourse/befrq.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Locale 결정 : Locale에 설정된 지역정보를 통해 지역화&lt;/li&gt;
  &lt;li&gt;RequestContextHolder에 요청 저장 : 요청을 받아 응답하기 이전까지 HTTPServlet Request, Response 객체를 저장함. –&amp;gt; 일반 빈에서 바로 선언해서 사용할 수 있도록 함&lt;/li&gt;
  &lt;li&gt;FlashMap 복원 : redirect로 파라미터 전달 시 URL을 복잡하게 하는부분들을 정리해주는 역할&lt;/li&gt;
  &lt;li&gt;멀티파트 요청인 경우,  요청 제어를 MultipartResolver로 넘김&lt;/li&gt;
  &lt;li&gt;핸들러 결정과 실행&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dispatcherservlet---&quot;&gt;DispatcherServlet &amp;gt; 요청처리 과정&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/boostcourse/handreq.png&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Jul 2019 21:00:00 +0900</pubDate>
        <link>http://lee95292.github.io/boostcourse/2019/07/08/BoostCourse-PJ3_Backend_Spring.html</link>
        <guid isPermaLink="true">http://lee95292.github.io/boostcourse/2019/07/08/BoostCourse-PJ3_Backend_Spring.html</guid>
        
        
        <category>boostcourse</category>
        
      </item>
    
  </channel>
</rss>
